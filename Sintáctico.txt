//// Conjunto de símbolos terminales
Terminales = { id cstr cint true false int boolean string void var function return for if input output ( ) { } = += + - < > && || , ; eof }

//// Conjunto de símbolo no terminales
NoTerminales = { P FUNCTION FUNTYPE VARTYPE FUNATTRIBUTES NEXTATTRIBUTE STATEMENT BODY ATOMSTATEMENT IDACT FORACT ASS CALLPARAM NEXTPARAM RETURNEXP EXP EXP1 LOGOP A A1 COMPOP B B1 ARITHMETICOP EXPATOM C }

//// Axioma
Axioma = P

//// Lista de producciones
Producciones = {

P -> FUNCTION P
P -> STATEMENT P
P -> eof

FUNCTION -> function FUNTYPE id ( FUNATTRIBUTES ) { BODY }

FUNTYPE -> void
FUNTYPE -> VARTYPE

VARTYPE -> int
VARTYPE -> boolean
VARTYPE -> string

FUNATTRIBUTES -> void
FUNATTRIBUTES -> VARTYPE id NEXTATTRIBUTE

NEXTATTRIBUTE -> , VARTYPE id NEXTATTRIBUTE
NEXTATTRIBUTE -> lambda

BODY -> STATEMENT BODY
BODY -> lambda

STATEMENT -> if ( EXP ) ATOMSTATEMENT
STATEMENT -> for ( FORACT ; EXP ; FORACT ) { BODY }
STATEMENT -> var VARTYPE id ;
STATEMENT -> ATOMSTATEMENT

ATOMSTATEMENT -> id IDACT ;
ATOMSTATEMENT -> output EXP ;
ATOMSTATEMENT -> input id ;
ATOMSTATEMENT -> return RETURNEXP ;

IDACT -> ASS EXP
IDACT -> ( CALLPARAM )

FORACT -> id ASS EXP
FORACT -> lambda

ASS -> =
ASS -> +=

CALLPARAM -> EXP NEXTPARAM
CALLPARAM -> lambda

NEXTPARAM -> , EXP NEXTPARAM
NEXTPARAM -> lambda

RETURNEXP -> EXP
RETURNEXP -> lambda

EXP -> A EXP1

EXP1 -> LOGOP A EXP1
EXP1 -> lambda

LOGOP -> &&
LOGOP -> ||

A -> B A1

A1 -> COMPOP B A1
A1 -> lambda

COMPOP -> >
COMPOP -> <

B -> EXPATOM B1

B1 -> ARITHMETICOP EXPATOM B1
B1 -> lambda

ARITHMETICOP -> +
ARITHMETICOP -> -

EXPATOM -> id C
EXPATOM -> ( EXP )
EXPATOM -> cint
EXPATOM -> cstr
EXPATOM -> true
EXPATOM -> false

C -> ( CALLPARAM )
C -> lambda

}
