\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{indentfirst}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage[table]{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tcolorbox}

\setlength{\headheight}{13.07225pt}
\addtolength{\topmargin}{-1.07225pt}

\fancypagestyle{plain}{
    \fancyhead[L]{}
    \fancyhead[C]{}
    \fancyhead[R]{}
    \renewcommand{\headrulewidth}{0pt}
    \fancyfoot[R]{\thepage}
    \fancyfoot[C]{}
    \fancyfoot[L]{Práctica 1 - Procesadores de Lenguajes}
}

\pagestyle{fancy}
\fancyhead[L]{Grupo 7}
\fancyhead[C]{}
\fancyfoot[R]{\thepage}
\fancyfoot[C]{}
\fancyfoot[L]{Práctica 1 - Procesadores de Lenguajes}

\title{\textbf{Práctica 1 - Procesadores de Lenguajes}}
\author{\textbf{Grupo 7}\\Carmen Toribio Pérez, 22M009\\Sergio Gil Atienza, 22M046\\María Moronta Carrión, 22M111}
\date{}

\begin{document}

\maketitle

\section{Introducción}

La primera entrega de esta práctica consiste en la implementación de un Analizador Léxico y una Tabla de Símbolos. Para ello, hemos seguido los siguientes pasos: 
\begin{enumerate}
    \item \textbf{Identificar los Tokens} del lenguaje fuente, teniendo en cuenta las especificaciones de nuestro grupo.
    \item Construir la \textbf{Gramática Regular} que los genera.
    \item Diseñar el \textbf{Autómata Finito Determinista} equivalente a la gramática. Hemos realizado una representación de este a través de un \textbf{diagrama de estados}.
    \item Añadir las \textbf{Acciones Semánticas}, asociadas a cada una de las transiciones del diagrama de estados.
    \item Estudiar los posibles \textbf{casos de error}, para poder manejar correctamente la detección y el reporte de errores léxicos. 
\end{enumerate}
 
 Por otro lado, hemos comenzado con la implementación de la \textbf{Tabla de Símbolos}, concretamente con el diseño de su estructura y su organización.\\

 Finalmente, presentamos una serie de casos de prueba que demuestran el correcto funcionamiento del Procesador, así como su capacidad para manejar errores léxicos.\\

Como integrantes del \textbf{grupo 7}, hemos tenido que cumplir con las siguientes especificaciones: 
\begin{itemize}[left=2cm]
    \item Sentencias: Sentencia repetitiva (for)
    \item Operadores especiales: Asignación con suma (+=)
    \item Técnicas de Análisis Sintáctico: Descendente Recursivo
    \item Comentarios: Comentario de bloque (/* */)
    \item Cadenas: Con comillas simples (' ')
\end{itemize}

Hemos decidido usar C++ como lenguaje de programación porque la mayor parte de la infraestructura de compiladores está escrita en C o en C++, incluyendo el proyecto LLVM (Low Level Virtual Machine). También hemos tenido en cuenta su flexibilidad y potencia, junto a la amplia variedad de utilidades que tiene su librería estándar. En comparación con lenguajes como Java o JavaScript, C++ ofrece mayor eficiencia y control sobre los recursos del sistema, algo crucial en proyectos como este (que requieren optimización de bajo nivel). Además, consideramos este proyecto como una gran oportunidad para practicar y aprender un lenguaje completamente distinto a los que estamos acostumbrados.

\newpage

\section{Tokens}
El primer paso a la hora de construir un Analizador Léxico es la identificación de los tokens. Para hacer la lista nos hemos basado en la actividad práctica de la plataforma Draco. Hemos decidido utilizar el mismo formato en tablas con tal de facilitar su legibilidad.\\
Tokens obligatorios:

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
		\rowcolor{gray!20} % color grisaceo en la cabecera de la tabla
        \textbf{Elemento} & \textbf{Código de Token} & \textbf{Atributo} \\ \hline
        boolean & bool & - \\ \hline
        for & for & - \\ \hline
        function & fn & - \\ \hline
        if & if & - \\ \hline
        input & in & - \\ \hline
        int & int & - \\ \hline
        output & out & - \\ \hline
        return & ret & - \\ \hline
        string & str & - \\ \hline
        var & var & - \\ \hline
        void & void & - \\ \hline
        constante entera & cint & Número \\ \hline
        Cadena (') & cstr & Cadena ("c*") \\ \hline
		Identificador & id & Número (posición en la TS) \\ \hline
        += & cumass & - \\ \hline
        = & ass & - \\ \hline
        , & com & - \\ \hline
        ; & scol & - \\ \hline
        ( & po & - \\ \hline
        ) & pc & - \\ \hline
        \{ & cbo & - \\ \hline
        \} & cbc & - \\ \hline
    \end{tabular}
\end{table}

Tokens de operadores aritméticos, lógicos y relcionales:
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
		\rowcolor{gray!20} % color grisaceo en la cabecera de la tabla
        \textbf{Grupo de Opciones} & \textbf{Código de Token} & \textbf{Atributo} \\ \hline
        Grupo Operadores Aritméticos: Suma (+) & sum & - \\ \hline
        Grupo Operadores Aritméticos: Resta (-) & sub & - \\ \hline
        Grupo Operadores Lógicos: Y lógico (\&\&) & and & - \\ \hline
        Grupo Operadores Lógicos: O lógico (\texttt{||}) & or & - \\ \hline
        Grupo Operadores Relacionales: Menor (\textless) & ls & - \\ \hline
        Grupo Operadores Relacionales: Mayor (\textgreater) & gr & - \\ \hline
    \end{tabular}
\end{table}

Tokens opcionales:
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
		\rowcolor{gray!20} % color grisaceo en la cabecera de la tabla
        \textbf{Grupo de Opciones} & \textbf{Código de Token} & \textbf{Atributo} \\ \hline
        Menos Unario (-) & sub & - \\ \hline
        Más Unario (+) & sum & - \\ \hline
        false & cap & - \\ \hline
        true & nocap & - \\ \hline
        EOF & eof & - \\ \hline
    \end{tabular}
\end{table}

Por tanto, los siguientes tipos de expresiones no serán identificados como tokens: los delimitadores (como los espacios en blanco o las tabulaciones), los comentarios de bloque (/* */) o los saltos de línea (\textbackslash n).

\section{Gramática Regular}

En esta sección, describimos la Gramática Regular (gramática de tipo 3 según la jerarquía de Chomsky) que hemos diseñado para identificar y generar los tokens del lenguaje fuente. 

\vspace{0.1cm}

\begin{center}
    \begin{tcolorbox}[title=Símbolos no terminales, width=0.57\textwidth]
        $d$ := 0...9
        
        $l$ := a..z, A...Z
        
        $c_1$ := espacio o cualquier carácter imprimible menos \textbackslash
        
        $cesc$ := carácter escapable (', 0, n, a, t, v, f, r, \textbackslash )
        
        $c_2$ := cualquier carácter menos * y eof
        
        $c_3$ := cualquier carácter menos *, / y eof
    \end{tcolorbox}
\end{center}

\begin{tcolorbox}[title=Gramática Regular]
    \hspace{0.5cm} S → del S \texttt{|} $l$A \texttt{|} $d$B \texttt{|} 'C \texttt{|} +D\texttt{|} - \texttt{|} = \texttt{|} \(>\) \texttt{|} \(<\) \texttt{|} \&E \texttt{|} \texttt{|}F \texttt{|} /G \texttt{|} \} \texttt{|} \{ \texttt{|} ) \texttt{|} ( \texttt{|} ; \texttt{|} , \texttt{|} eof
    
    \hspace{0.5cm} A → $l$A \texttt{|} $d$A \texttt{|} \_A \texttt{|} \( \lambda \)
    
    \hspace{0.5cm} B → $d$B \texttt{|} \( \lambda \)
    
    \hspace{0.5cm} C → $c_1$C \texttt{|} \textbackslash C' \texttt{|} '
    
    \hspace{0.5cm} C' → $cesc$C
    
    \hspace{0.5cm} D → = \texttt{|} \( \lambda \)
    
    \hspace{0.5cm} E → \&
    
    \hspace{0.5cm} F → \texttt{|}
    
    \hspace{0.5cm} G → *H
    
    \hspace{0.5cm} H → $c_2$H \texttt{|} *I
    
    \hspace{0.5cm} I → /S \texttt{|} $c_3$H \texttt{|} *I
\end{tcolorbox}

\section{Autómata Finito Determinista}
Una vez definida la gramática regular, el siguiente paso es construir el Autómata Finito Determinista (AFD) correspondiente. A continuación, presentamos su diseño, incluyendo las transiciones entre estados.

\vspace{0.1cm}

\input{AFD.tex}

\section{Acciones semánticas}
A lo largo de esta sección, describimos las acciones semánticas que hemos añadido a las transiciones del Autómata Finito Determinista. Estas acciones permiten que se lleven a cabo acciones como la lectura, la identificación de los tokens o, en su lugar, una correcta gestión de los errores léxicos. A continuación, detallamos las operaciones utilizadas y, por legibilidad en el AFD, las transiciones en las que se realiza cada una:\\
\begin{tabbing}
    \hspace{1cm}\=\hspace{5cm}\=\kill
    \textbf{Leer:} \\
    \> car := leer(); \> // Todas las transiciones salvo 1:2, 3:4, 6:5, 8:9 con un carácter\\
    \> \hspace{5cm}// distinto de '=', y 0:19\\
    \> car := leerCesc(); \> // Transición 6:5. Leído un caracter de escape, devuelve el carácter\\
    \> \hspace{5cm}// correspondiente (por ejemplo un 'n' devuelve un eol)
    \\
    \textbf{Concatenar:} \\
    \> lex := car; \> // Transición 0:1 \\
    \> lex := $\emptyset$; \> // Transición 0:5 \\
    \> lex := lex $\oplus$  car; \> // Transiciones 1:1, 5:5 y 6:5\\
    \\
    \textbf{Contador:} \\
    \> // Utilizado para contar el número de caracteres de la cadena \\
    \> cont := 0; \> // Transición 0:5. Inicializa el contador a 0\\
    \> cont := cont + 1; \> // Transiciones 5:5 y 6:5 \\
    \\
    \textbf{Calcular valor entero:} \\
    \> // La función val(car) devuelve el valor entero del dígito correspondiente al carácter car\\
    \> num := val(car); \> // Transición 0:3 \\
    \> num := num * 10 + val(car); \> // Transición 3:3 \\
    \\
    \hspace{1cm}\=\hspace{1cm}\=\hspace{7cm}\=\kill %cambio la indentación porque ahora habrá más tabulaciones que hacer
    \textbf{Generar token:} \\
    \textit{Cadenas y enteros} \\
    \> G1 \> if (cont $>$ 64) \> // Transición 5:7 \\
    \> \hspace{1.5cm} then error (COD\_ERROR\_STRLEN, lex) \\
    \> \hspace{1cm}else Gen\_token(cstr, lex) \\
    \> G2 \> Gen\_token(cint, num) \> // Transición 3:4 \\
    \textit{Delimitadores y operadores de control} \\
    \> G3 \> Gen\_token(cumass, -) \> // Transición 8:9 con el carácter '='\\
    \> G4 \> Gen\_token(ass, -) \> // Transición 0:10 con el carácter '='\\
    \> G5 \> Gen\_token(com, -) \> // Transición 0:18 con el carácter ','\\
    \> G6 \> Gen\_token(scol, -) \> // Transición 0:18 con el carácter ';'\\
    \> G7 \> Gen\_token(po, -) \> // Transición 0:18 con el carácter '('\\
    \> G8 \> Gen\_token(pc, -) \> // Transición 0:18 con el carácter ')'\\
    \> G9 \> Gen\_token(cbo, -) \> // Transición 0:18 con el carácter '\{'\\
    \> G10 \> Gen\_token(cbc, -) \> // Transición 0:18 con el carácter '\}' \\
    \textit{Operadores Aritméticos, Lógicos y Relacionales} \\
    \> G11 \> Gen\_token(sum, -) \> // Transición 8:9 con un carácter distinto de '='\\
    \> G12 \> Gen\_token(sub, -) \> // Transición 0:10 con el carácter '-'\\
    \> G13 \> Gen\_token(and, -) \> // Transición 11:12 \\
    \> G14 \> Gen\_token(or, -) \> // Transición 13:14 \\
    \> G15 \> Gen\_token(ls, -) \> // Transición 0:10 con el carácter '$<$'\\
    \> G16 \> Gen\_token(gr, -) \> // Transición 0:10 con el carácter '$>$'\\
    \textit{Fin de fichero (EOF)} \\
    \> G17 \> Gen\_token(eof, -) \> // Transición 0:19 \\
\end{tabbing}
\newpage
\begin{tabbing}
    \hspace{1cm}\=\hspace{1cm}\=\hspace{7cm}\=\kill
    \textit{Identificadores y palabras reservadas} \\
    \> G18 \> type := GetTokenCode(lex);*\> // Transición 1:2\\
    \> \hspace{1cm}if type = id then\\
    \> \hspace{2cm}pos := SearchST(lex);**\\
    \> \hspace{2cm}if pos = NULL then\\
    \> \hspace{3cm}pos := AddID(lex);***\\
    \> \hspace{2cm}Gen\_Token(type, pos);\\
    \> \hspace{1cm}else\\
    \> \hspace{2cm}Gen\_Token(type, -);\\
    \>* La función GetTokenCode(lex) devuelve el código de token de la palabra reservada \\
    \>con la que coincida lex, o el código de ID si no es palabra reservada\\
    \>** La función SearchST(lex) devuelve la posición del identificador lex en la tabla \\
    \>de símbolos, o NULL si no ha sido insertado aún\\
    \>*** La función AddID(lex) inserta el identificador lex en la tabla de símbolos y \\
    \>devuelve su posición\\
\end{tabbing}

\section{Gestión de errores}
Explicando los casos de error posibles, los códigos de error asignados a cada caso, etc.

\section{Tabla de Símbolos}
Solo tiene identificadores y su posición, de momento. "muchotexto mimimi".

\section{Funcionamiento del programa}
Breve explicación de lo que hace nuestro programa.

\end{document}
